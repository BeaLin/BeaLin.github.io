<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Python学习笔记 | BeaLin&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Programmer,Technology,Software Engineering">
<meta property="og:type" content="article">
<meta property="og:title" content="Python学习笔记">
<meta property="og:url" content="http://yoursite.com/2016/05/13/Python学习笔记/index.html">
<meta property="og:site_name" content="BeaLin's Blog">
<meta property="og:description" content="Programmer,Technology,Software Engineering">
<meta property="og:image" content="http://o73nd1ra4.bkt.clouddn.com/Unicode.png">
<meta property="og:image" content="http://o73nd1ra4.bkt.clouddn.com/encode1.png">
<meta property="og:image" content="http://o73nd1ra4.bkt.clouddn.com/format.png">
<meta property="og:image" content="http://o73nd1ra4.bkt.clouddn.com/DLanguage.png">
<meta property="og:image" content="http://o73nd1ra4.bkt.clouddn.com/QLanguage1.png">
<meta property="og:image" content="http://o73nd1ra4.bkt.clouddn.com/QLanguage2.png">
<meta property="og:image" content="http://o73nd1ra4.bkt.clouddn.com/if.png">
<meta property="og:image" content="http://o73nd1ra4.bkt.clouddn.com/for.png">
<meta property="og:image" content="http://o73nd1ra4.bkt.clouddn.com/while.png">
<meta property="og:updated_time" content="2016-05-23T03:26:52.344Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python学习笔记">
<meta name="twitter:description" content="Programmer,Technology,Software Engineering">
<meta name="twitter:image" content="http://o73nd1ra4.bkt.clouddn.com/Unicode.png">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?1d80e95307276f5c52c3e32dae69f024";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">BeaLin&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Study, Think, Record</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-github-link" class="nav-icon" href="https://github.com/BeaLin" title="Github" target="_blank"></a>
        
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Python学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
<a href="/2016/05/13/Python学习笔记/" class="article-date">
  <time datetime="2016-05-13T03:24:33.000Z" itemprop="datePublished">2016-05-13</time>
</a>


    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Python学习笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
		
		<div id="toc" class="toc-article">
			<h2 class="toc-title"><span>Contents</span></h2>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Python基础"><span class="toc-number">1.</span> <span class="toc-text">Python基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据类型和变量"><span class="toc-number">1.1.</span> <span class="toc-text">数据类型和变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件判断"><span class="toc-number">1.2.</span> <span class="toc-text">条件判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#循环"><span class="toc-number">1.3.</span> <span class="toc-text">循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#列表"><span class="toc-number">1.4.</span> <span class="toc-text">列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元祖tuple"><span class="toc-number">1.5.</span> <span class="toc-text">元祖tuple</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字典"><span class="toc-number">1.6.</span> <span class="toc-text">字典</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合"><span class="toc-number">1.7.</span> <span class="toc-text">集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数"><span class="toc-number">2.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数参数"><span class="toc-number">2.1.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归函数"><span class="toc-number">2.2.</span> <span class="toc-text">递归函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数式编程"><span class="toc-number">2.3.</span> <span class="toc-text">函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#高阶函数"><span class="toc-number">2.3.1.</span> <span class="toc-text">高阶函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#返回函数"><span class="toc-number">2.3.2.</span> <span class="toc-text">返回函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#匿名函数：不需要显示地定义函数"><span class="toc-number">2.3.3.</span> <span class="toc-text">匿名函数：不需要显示地定义函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#装饰器"><span class="toc-number">2.3.4.</span> <span class="toc-text">装饰器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#偏函数"><span class="toc-number">2.3.5.</span> <span class="toc-text">偏函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象"><span class="toc-number">3.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#继承与多态"><span class="toc-number">3.1.</span> <span class="toc-text">继承与多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象信息"><span class="toc-number">3.2.</span> <span class="toc-text">对象信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例属性和类属性"><span class="toc-number">3.3.</span> <span class="toc-text">实例属性和类属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多重继承"><span class="toc-number">3.4.</span> <span class="toc-text">多重继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定制类"><span class="toc-number">3.5.</span> <span class="toc-text">定制类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用枚举类"><span class="toc-number">3.6.</span> <span class="toc-text">使用枚举类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元类"><span class="toc-number">3.7.</span> <span class="toc-text">元类</span></a></li></ol></li></ol>
		
		</div>
		
        <p>由于项目需要，最近开始学Python。Python是一种面向对象、解释型语言。也是最近非常火的一种语言。Python为我们提供了非常完善的基础代码库，涵盖了网络、文件、GUI、数据库、文本等大量内容。Python非常简单，有一定面向对象知识的同学都可以很快地入门并深入。但是Python也有缺点：一个是运行速度慢；一个是代码不能加密。因为Python是解释型语言，所以代码在执行时会一行一行地翻译成CPU能理解地机器码。这个翻译过程很耗时。我学习Python的目的主要是为了编写爬虫代码和学习机器学习知识。所以对Python的学习程度并不需要达到深层次。我为了快速入门，选择<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="external">廖雪峰的官方网站中的Python3教程</a>进行学习。本文主要是我学习过程记下的笔记，着重于与java不太一样的地方。个人笔记仅供参考。<br><a id="more"></a></p>
<h2 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h2><h3 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h3><ol>
<li>整数：十六进制用0x前缀和0-9，a-f表示</li>
<li>浮点数：小数，科学计数法：10用e代替；整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（包括除法），浮点数运算则可能会有四舍五入的误差</li>
<li>字符串和编码<br>(1) 以单引号’或双引号”括起来的任意文本。<br>(2) 可以用转义字符\来标识’和”。(\n:换行(Python允许使用’’’…’’’格式表示多行内容,eg。’’’a…b…c’’’),\t:制表符,\:表示\,)<br>(3) r’’表示’’内部的字符默认不转义<br>(4) 编码:<br><img src="http://o73nd1ra4.bkt.clouddn.com/Unicode.png" alt=""></li>
</ol>
<p><strong>ASCII编码:</strong>1个字节（包括大小写英文字母，数字和一些符号）<br><strong>Unicode编码:</strong>把所有语言都统一到一套编码里，清除乱码问题（多为2字节，把ASCII编码的字符用Unicode编码，在前面补8个0）<br><strong>UTF-8:</strong>把Unicode编码转化为“可变长编码“，因为Unicode编码比ASCII编码需要多一倍的存储空间，若文本全为英文的话，及其不节约。<br>~~ASCII编码实际上可以被看成是UTF-8编码的一部分。<br>~~在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就装换为UTF-8编码<br>(5) Python3版本中，字符串是以Unicode编码，即支持多语言。ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符。<br>(6) 如果要在网络上传输，或者保存到磁盘上，就需要把字符串变为以字节为单位的bytes，用带b前缀的单引号或双引号表示：x=b’ABC’。encode()将字符变为bytes，decode()将bytes变为字符。<br><img src="http://o73nd1ra4.bkt.clouddn.com/encode1.png" alt=""><br>(7) 在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。<br>(8) 由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：</p>
<pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-
</code></pre><ul>
<li>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</li>
<li>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</li>
<li>申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码：</li>
</ul>
<p>(9) 格式化：%<br><img src="http://o73nd1ra4.bkt.clouddn.com/format.png" alt=""><br>%d：整数<br>%f：浮点数<br>%s：字符串<br>%x：十六进制整数<br>%%：%</p>
<ol>
<li>布尔值：True和False；and、or和not运算<br>在python中，and和or执行布尔逻辑运算时，并不返回布尔值，而是返回他们实际进行比较的值之一。在布尔上下文中从左到右演算表达式的值。对于and，如果布尔上下文中的所有值为真，那么and返回最后一个值；如果布尔上下文中的某个值为假，则and返回第一个假值。对于or，如果有值为真，则返回第一个真值，若所有值都为假，则返回最后一个假值。</li>
<li>空值：None，不能理解为0。</li>
<li>变量：变量名必须是大小写英文、数字和_的组合。<br>动态语言：<br><img src="http://o73nd1ra4.bkt.clouddn.com/DLanguage.png" alt=""><br>静态语言：<br><img src="http://o73nd1ra4.bkt.clouddn.com/QLanguage1.png" alt=""><br><img src="http://o73nd1ra4.bkt.clouddn.com/QLanguage2.png" alt=""><br>b:ABC</li>
<li>常量：通常用全部大写的变量名表示常量</li>
<li>1.1+1.1+1.1=3.3000000000003：因为精度损失</li>
</ol>
<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p><img src="http://o73nd1ra4.bkt.clouddn.com/if.png" alt=""></p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ol>
<li>for x in ..<br><img src="http://o73nd1ra4.bkt.clouddn.com/for.png" alt=""></li>
<li>while<br><img src="http://o73nd1ra4.bkt.clouddn.com/while.png" alt=""></li>
</ol>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ol>
<li>list是一种有序的集合，可以随时添加和删除其中的元素<br>classmates = [‘Michael’, ‘Bob’, ‘Tracy’]</li>
<li>用len()函数可以获得list元素的个数，用索引来访问list中每一个位置的元素，记得索引是从0开始的当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得最后一个元素的索引是len(classmates) - 1。</li>
<li>如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素。</li>
<li>list元素也可以是另一个list</li>
</ol>
<h3 id="元祖tuple"><a href="#元祖tuple" class="headerlink" title="元祖tuple"></a>元祖tuple</h3><ol>
<li>不可变的列表(指向永远不变)；除改变列表内容的方法外，其他方法均适用于元组；因此：索引、切片、len、print可用；append、extend、del等不可用<br>classmates = (‘Michael’, ‘Bob’, ‘Tracy’)</li>
<li>因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。</li>
<li>定义一个空的tuple：t = ()</li>
<li>t=(1):定义的不是tuple，而是1这个数，只有1个元素的tuple定义时必须加一个逗号，。t=(1,)</li>
</ol>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><ol>
<li>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度<br> my_dict={‘john’:1234,’Mike’:5678,’Bob’:8765}<br> my_dict[‘Bob’]</li>
<li>给定一个名字，比如’Michael’：95，dict在内部就可以直接计算出Michael对应的存放成绩的“页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快</li>
<li>dict内部存放的顺序和key放入的顺序是没有关系的</li>
<li>和list比较，查找和插入的速度极快，不会随着key的增加而增加；需要占用大量的内存，内存浪费多。</li>
<li>要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key</li>
<li><p>字典预算符合方法</p>
<p> len(my_dict)<br> key in my_dict         快速判断key是否为字典中的键：O(1)；==my_dict.has_key(key)<br> for key in my_dict     枚举字典中的键：键是无序的<br> my_dict.items()         全部的键-值对；返回的键值对是以列表的形式<br> my_dict.keys()         全部的键<br> my_dict.values()     全部的值<br> my_dict.clear()         清空字典</p>
</li>
</ol>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ol>
<li><p>无序不重复元素（键）集；和字典类似，但是无“值”</p>
<p> 创建:            x=set（）</p>
<pre><code>x={key1,key2,...}
</code></pre><p> 添加和删除:        x.add(‘body’)</p>
<pre><code>x.remove(&apos;body&apos;)
</code></pre><p> 集合的运算符:     -      &amp;     |     ！=    </p>
</li>
<li>set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”</li>
<li><p>中文分词————算法：正向最大匹配（从左到右取尽可能长的词）<br>(1) 加载词典：lexicon.txt</p>
<p> def load_dic(filename):</p>
<pre><code>f= open(filename)
word_dic=set()
max_length=1
for line in f:
    word=unicode(line.strip(),&apos;utf-8&apos;)
    word_dict.add(word)
    if len(word)&gt;max_len:
        max_len=len(word)
return max_len,word_dict
</code></pre></li>
</ol>
<p>(2) 正向最大匹配分词</p>
<pre><code>def fmm_word_seg(sent,max_len,word_dict):
    begin=0
    words=[]
    sent=unicode(sent,&apos;utf-8&apos;)
    while begin&lt;len(sent):
        for end in range(begin+max_len,begin,-1):
            if sent[begin:end] in word_dict:
                words.append(sent[begin:end])
                break
        begin=end
    return words  
</code></pre><p>(3)应用</p>
<pre><code>max_len,word_dict=load_dict(&apos;lexcion.txt&apos;)     
sent=raw_input(&apos;Input a sententce:&apos;)     
words =fmm_word_seg(sent,max_len,word_dict)
for word in words:
    print word
</code></pre><hr>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>函数参数：位置参数、默认参数、可变参数、关键字参数（命名关键字参数）</p>
<ol>
<li>位置参数:普通的传参方式</li>
<li>默认参数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x, n=<span class="number">2</span>)</span>:</span></span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        s = s * x</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>power(<span class="number">5</span>)</span><br><span class="line"><span class="number">25</span>&gt;&gt;&gt; power(<span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure>
<p>！定义默认参数必须指向不可变对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(<span class="string">'END'</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure></p>
<ol>
<li>可变参数：允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(*numbers)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(*nums)</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure>
<ol>
<li>关键字参数：允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict<br>作用：扩展函数的功能。用途：注册时，除必填项外，利用关键字参数还可以传入可选项。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Michael'</span>, <span class="number">30</span>)</span><br><span class="line">name: Michael age: <span class="number">30</span> other: &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Bob'</span>, <span class="number">35</span>, city=<span class="string">'Beijing'</span>)</span><br><span class="line">name: Bob age: <span class="number">35</span> other: &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Adam'</span>, <span class="number">45</span>, gender=<span class="string">'M'</span>, job=<span class="string">'Engineer'</span>)</span><br><span class="line">name: Adam age: <span class="number">45</span> other: &#123;<span class="string">'gender'</span>: <span class="string">'M'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>extra = &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, **extra)</span><br><span class="line">name: Jack age: <span class="number">24</span> other: &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>extra表示把extra的一份拷贝传给kw，kw获得一个dict，对kw的改动不会影响到函数外的extra<br><strong>命名关键字：</strong>限制关键字参数的名字，需要一个特殊分隔符<em>，</em>后面的参数被视为命名关键字参数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city, job)</span>:</span></span><br><span class="line">    print(name, age, city, job)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, city=<span class="string">'Beijing'</span>, job=<span class="string">'Engineer'</span>)</span><br><span class="line">Jack <span class="number">24</span> Beijing Enginee</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果函数定义中已经有一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符</li>
<li>命名关键字参数必须传入参数名，这和位置参数不同，如果没有传入参数名，视为位置参数，调用将报错</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, <span class="string">'Beijing'</span>, <span class="string">'Engineer'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: person() takes <span class="number">2</span> positional arguments but <span class="number">4</span> were given</span><br></pre></td></tr></table></figure>
<ol>
<li>参数组合<br>在python中定义函数，可以组合使用上述5种参数，但参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(a,b,c=<span class="number">0</span>,*args,**kw)</span>:</span></span><br><span class="line">    print(<span class="string">'a='</span>,a,<span class="string">'b='</span>,b,<span class="string">'c='</span>,c,<span class="string">'args='</span>,args,<span class="string">'kw='</span>,kw)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(a,b,c=<span class="number">0</span>,*,d,**kw)</span>:</span></span><br><span class="line">    print(<span class="string">'a='</span>,a,<span class="string">'b='</span>,b,<span class="string">'c='</span>,c,<span class="string">'d='</span>,d,<span class="string">'kw='</span>,kw)</span><br><span class="line">f1(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">f1(<span class="number">1</span>,<span class="number">2</span>,c=<span class="number">3</span>)</span><br><span class="line">f1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">'a'</span>,<span class="string">'b'</span>)</span><br><span class="line">f1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,x=<span class="number">99</span>)</span><br><span class="line">f2(<span class="number">1</span>,<span class="number">2</span>,d=<span class="number">99</span>,ext=<span class="keyword">None</span>)</span><br><span class="line">f2(<span class="number">1</span>,<span class="number">2</span>,dd=<span class="number">11</span>,d=<span class="number">99</span>,ext=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a= <span class="number">1</span> b= <span class="number">2</span> c= <span class="number">0</span> args= () kw= &#123;&#125;</span><br><span class="line">a= <span class="number">1</span> b= <span class="number">2</span> c= <span class="number">3</span> args= () kw= &#123;&#125;</span><br><span class="line">a= <span class="number">1</span> b= <span class="number">2</span> c= <span class="number">3</span> args= (<span class="string">'a'</span>, <span class="string">'b'</span>) kw= &#123;&#125;</span><br><span class="line">a= <span class="number">1</span> b= <span class="number">2</span> c= <span class="number">3</span> args= (<span class="string">'a'</span>, <span class="string">'b'</span>) kw= &#123;<span class="string">'x'</span>: <span class="number">99</span>&#125;</span><br><span class="line">a= <span class="number">1</span> b= <span class="number">2</span> c= <span class="number">0</span> d= <span class="number">99</span> kw= &#123;<span class="string">'ext'</span>: <span class="keyword">None</span>&#125;</span><br><span class="line">a= <span class="number">1</span> b= <span class="number">2</span> c= <span class="number">0</span> d= <span class="number">99</span> kw= &#123;<span class="string">'ext'</span>: <span class="keyword">None</span>, <span class="string">'dd'</span>: <span class="number">11</span>&#125;</span><br></pre></td></tr></table></figure>
<p>最神奇的是通过一个tuple和dict，你也可以调用上述函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kw = &#123;<span class="string">'d'</span>: <span class="number">99</span>, <span class="string">'x'</span>: <span class="string">'#'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(*args, **kw)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="number">4</span>,) kw = &#123;<span class="string">'d'</span>: <span class="number">99</span>, <span class="string">'x'</span>: <span class="string">'#'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kw = &#123;<span class="string">'d'</span>: <span class="number">88</span>, <span class="string">'x'</span>: <span class="string">'#'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2(*args, **kw)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> d = <span class="number">88</span> kw = &#123;<span class="string">'x'</span>: <span class="string">'#'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，对于任意函数，都可以通过类似func(<em>args, *</em>kw)的形式调用它，无论它的参数是如何定义的。</p>
<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p><strong>函数调用</strong>是通过栈实现，所以使用递归函数需要注意防止栈溢出。<br><strong>解决递归调用栈溢出的方法</strong>是通过<strong>尾递归优化</strong>，事实上尾递归和循环的效果是一样的，所以，可以把循环看成是一种特殊的尾递归函数。<br><strong>尾递归：</strong>在函数返回的时候，调用自身本身，并且return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> fact_iter(n, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact_iter</span><span class="params">(num, product)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> product</span><br><span class="line">    <span class="keyword">return</span> fact_iter(num - <span class="number">1</span>, num * product)</span><br></pre></td></tr></table></figure>
<p>尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。<br><strong>遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。</strong></p>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>高阶函数: 把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式。</p>
<ol>
<li>map/reduce<br>(1) map()<br>map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。 Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalize</span><span class="params">(name)</span>:</span></span><br><span class="line">    name=name.title()</span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line">L=[<span class="string">'adam'</span>,<span class="string">'LISA'</span>,<span class="string">'barT'</span>]</span><br><span class="line">print(list(map(normalize,L)))</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>(2)reduce()<br>reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：<br>    reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</p>
<ol>
<li>filter：过滤序列<br>和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</li>
</ol>
<p>生成素数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_odd_iter</span><span class="params">()</span>:</span></span><br><span class="line">    n=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        n=n+<span class="number">2</span></span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_not_divisible</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x:x%n&gt;<span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">primes</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    it=_odd_iter()</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        n=next(it)</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        it = filter(_not_divisible(n),it)</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> primes():</span><br><span class="line">    <span class="keyword">if</span> n&lt;<span class="number">1000</span>:</span><br><span class="line">        print(n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<p><strong>yield:</strong>yield 的作用就是把一个函数变成一个 generator，带有 yield 的函数不再是一个普通函数，Python 解释器会将其视为一个 generator， 调用primes() 不会执行 fab 函数，而是返回一个 iterable 对象！在 for 循环执行时，每次循环都会执行 primes() 函数内部的代码，执行到 yield n 时，primes函数就返回一个迭代值，下次迭代时，代码从 yield n 的下一条语句继续执行，而函数的本地变量看起来和上次中断执行前是完全一样的，于是函数继续执行，直到再次遇到 yield。</p>
<ol>
<li>sorted<br>sorted()也是一个高阶函数，用sorted排序的关键在于实现一个映射函数， 它可以接收一个key函数来实现自定义的排序<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">-12</span>, <span class="number">9</span>, <span class="number">-21</span>])</span><br><span class="line">[<span class="number">-21</span>, <span class="number">-12</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">36</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">-12</span>, <span class="number">9</span>, <span class="number">-21</span>], key=abs)</span><br><span class="line">[<span class="number">5</span>, <span class="number">9</span>, <span class="number">-12</span>, <span class="number">-21</span>, <span class="number">36</span>]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以传入第三个参数reverse=True， 进行反向排序<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>], key=str.lower, reverse=<span class="keyword">True</span>)</span><br><span class="line">[<span class="string">'Zoo'</span>, <span class="string">'Credit'</span>, <span class="string">'bob'</span>, <span class="string">'about'</span>]</span><br></pre></td></tr></table></figure></p>
<h4 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h4><ol>
<li>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</li>
<li>内部函数可以引用外部函数的参数和局部变量，当外部函数返回内部函数时，相关参数和变量都保存在返回的函数中，这种程序结构称为闭包。</li>
<li>每次调用都会返回一个新的函数，即使传入相同的参数。</li>
<li>返回一个函数时，牢记该函数并未执行，直到调用了f()才执行。所以返回函数中不要引用任何可能会变化的变量。</li>
</ol>
<h4 id="匿名函数：不需要显示地定义函数"><a href="#匿名函数：不需要显示地定义函数" class="headerlink" title="匿名函数：不需要显示地定义函数"></a>匿名函数：不需要显示地定义函数</h4><pre><code>lambda x: x * x
</code></pre><ol>
<li>关键字lambda表示匿名函数，冒号前面的x表示函数参数。</li>
<li>匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。</li>
<li>匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数</li>
</ol>
<h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><ol>
<li>函数是一个对象，可以赋值给一个变量，也可以通过变量来调用该函数。</li>
<li>若要增强某个函数的功能，比如在函数调用前后自动打印日志，但又不希望修改函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">        @functools.wraps(func) #把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kw)</span>:</span></span><br><span class="line">            print(<span class="string">'%s %s()'</span>%(text,func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args,**kw)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@log('execute')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"2015-3-1"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>now()  #相当于 now=log(‘execute’)(now)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(textOrFunc)</span>:</span></span><br><span class="line">    text = textOrFunc <span class="keyword">if</span> isinstance(textOrFunc, str) <span class="keyword">else</span>  <span class="string">''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">        @functools.wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">            print(text)</span><br><span class="line">            print(<span class="string">'bengin call %s()'</span> % ( func.__name__))</span><br><span class="line">            func(*args, **kw)</span><br><span class="line">            print(<span class="string">'end call %s()'</span> % ( func.__name__))</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator <span class="keyword">if</span> isinstance(textOrFunc, str) <span class="keyword">else</span> decorator(textOrFunc)</span><br><span class="line"><span class="meta">@log('execute')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"2015-3-1"</span>)</span><br><span class="line">now()</span><br><span class="line">print(now.__name__)</span><br></pre></td></tr></table></figure></p>
<h4 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h4><p>当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。<br>functools.partial就是帮助我们创建一个偏函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2 = functools.partial(int, base=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1000000'</span>)</span><br><span class="line"><span class="number">64</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Animal is running"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Dog is running"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Timer is running"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runtwise</span><span class="params">(animal)</span>:</span></span><br><span class="line">    animal.run()</span><br><span class="line">    animal.run()</span><br><span class="line">runtwise(Animal())</span><br><span class="line">runtwise(Dog())</span><br><span class="line">runtwise(Timer())</span><br></pre></td></tr></table></figure>
<p>因为python是动态语言（鸭子类型），所以不一定需要传入Animal类型或其子类型，只需要保证传入的对象有一个run()方法就可以了。</p>
<h3 id="对象信息"><a href="#对象信息" class="headerlink" title="对象信息"></a>对象信息</h3><ol>
<li>type()：返回对象类型<br>~使用types模块中定义的常量来判断一个对象是否是函数。</li>
<li>isinstance():判断对象是否是同一类型；对于class的继承关系，type()很不方便，可以使用isinstance()函数</li>
<li>dir()：获得一个对象的所有属性和方法，返回一个包含字符串的list</li>
</ol>
<h3 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h3><p>因为python是动态语言，所以根据累创建的实例可以任意绑定属性<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span>...     name = <span class="string">'Student'</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student() <span class="comment"># 创建实例s&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span></span><br><span class="line">Student</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Student.name) <span class="comment"># 打印类的name属性</span></span><br><span class="line">Student</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">'Michael'</span> <span class="comment"># 给实例绑定name属性&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span></span><br><span class="line">Michael</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Student.name) <span class="comment"># 但是类属性并未消失，用Student.name仍然可以访问</span></span><br><span class="line">Student</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> s.name <span class="comment"># 如果删除实例的name属性&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span></span><br><span class="line">Student</span><br></pre></td></tr></table></figure></p>
<p>编写程序的时候，千万不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。<br>Python允许在定义class的时候，定义一个特殊的<strong>slots</strong>变量，来限制该class实例能添加的属性：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">'name'</span>, <span class="string">'age'</span>) <span class="comment"># 用tuple定义允许绑定的属性名称</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student() <span class="comment"># 创建新的实例&gt;&gt;&gt; s.name = 'Michael' # 绑定属性'name'&gt;&gt;&gt; s.age = 25 # 绑定属性'age'&gt;&gt;&gt; s.score = 99 # 绑定属性'score'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'Student'</span> object has no attribute <span class="string">'score'</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>@property<br>Python内置的@property装饰器就是负责把一个方法变成属性调用的： 既能检查参数，又可以用类似属性这样简单的方式<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must be an integer!'</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must between 0 ~ 100!'</span>)</span><br><span class="line">        self._score = value</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">60</span> <span class="comment"># OK，实际转化为s.set_score(60)&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()60&gt;&gt;&gt; s.score = 9999</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between <span class="number">0</span> ~ <span class="number">100</span>!</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值， 还可以定义只读属性。</p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Mammal, Runnable)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><strong>MixIn:</strong>一种常见的设计。MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。</p>
<h3 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h3><p><strong>1. <strong>str</strong>()与<strong>repr</strong>()</strong><br><strong>str</strong>()返回用户看到的字符串，而<strong>repr</strong>()返回程序开发者看到的字符串，也就是说，<strong>repr</strong>()是为调试服务的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Student object (name=%s)'</span> % self.name</span><br><span class="line">    __repr__ = __str__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Student(<span class="string">'Michael'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Student(<span class="string">'Michael'</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>2. <strong>iter</strong></strong><br>如果一个类想被用于for … in循环，类似list或tuple那样，就必须实现一个<strong>iter</strong>()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<strong>next</strong>()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a,self.b=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a,self.b=self.b,self.a+self.b</span><br><span class="line">        <span class="keyword">if</span> self.a&gt;<span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        <span class="keyword">return</span> self.a</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> Fib():</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure></p>
<p><strong>3. <strong>getitem</strong></strong><br>实现<strong>getitem</strong>()可以像list那样按照下标取出元素。<br>要正确实现一个<strong>getitem</strong>()还是有很多工作要做的，即切片和step参数<br><strong>4. <strong>getattr</strong> ：动态返回一个属性。</strong><br>只有在没有找到属性的情况下，才调用<strong>getattr</strong>，已有的属性，不会在<strong>getattr</strong>中查找。<br><strong>5. <strong>call</strong> ：只需要定义一个<strong>call</strong>()方法，就可以直接对实例进行调用。</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'My name is %s.'</span> % self.name)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">'Michael'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s() <span class="comment"># self参数不要传入</span></span><br><span class="line">My name <span class="keyword">is</span> Michael.</span><br></pre></td></tr></table></figure></p>
<p>通过callable()函数，我们就可以判断一个对象是否是“可调用”对象。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable(Student())</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable(<span class="string">'str'</span>)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<h3 id="使用枚举类"><a href="#使用枚举类" class="headerlink" title="使用枚举类"></a>使用枚举类</h3><p>为这样的枚举类型定义一个class类型： Enum类<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line">Month = Enum(<span class="string">'Month'</span>, (<span class="string">'Jan'</span>, <span class="string">'Feb'</span>, <span class="string">'Mar'</span>, <span class="string">'Apr'</span>, <span class="string">'May'</span>, <span class="string">'Jun'</span>, <span class="string">'Jul'</span>, <span class="string">'Aug'</span>, <span class="string">'Sep'</span>, <span class="string">'Oct'</span>, <span class="string">'Nov'</span>, <span class="string">'Dec'</span>))</span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique</span><br><span class="line"><span class="meta">@uniqueclass Weekday(Enum):</span></span><br><span class="line">    Sun = <span class="number">0</span> <span class="comment"># Sun的value被设定为0</span></span><br><span class="line">    Mon = <span class="number">1</span></span><br><span class="line">    Tue = <span class="number">2</span></span><br><span class="line">    Wed = <span class="number">3</span></span><br><span class="line">    Thu = <span class="number">4</span></span><br><span class="line">    Fri = <span class="number">5</span></span><br><span class="line">    Sat = <span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<p>@unique装饰器可以帮助我们检查保证没有重复值。 既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量。</p>
<h3 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h3><p>class的定义是运行时动态创建的，而创建class的方法就是使用type()函数。<br>type()函数既可以返回一个对象的类型，又可以创建出新的类型，<br>要创建一个class对象，type()函数依次传入3个参数：</p>
<ol>
<li>class的名称；</li>
<li>继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；</li>
<li>class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。</li>
</ol>
<p><strong>metaclass</strong><br>除了使用type()动态创建类以外，要控制类的创建行为，还可以使用metaclass。<br>先定义metaclass，就可以创建类，最后创建实例。  </p>

      
    </div>
    <footer class="article-footer">
	  
	  <!-- 百度分享 Start -->
	  <div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博"></a><a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a></div>
	  <!-- 百度分享 End -->
	  
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>

	  
<span>
Updated:<time datetime="2016-05-23T03:26:52.344Z" itemprop="dateModified">2016-05-23</time>
</span>


    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/05/13/使用Scrapy框架爬取数据/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          使用Scrapy框架爬取数据
        
      </div>
    </a>
  
  
    <a href="/2016/05/12/java内存模型JMM/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">Java内存模型JMM</div>
    </a>
  
</nav>

  
</article>




<!-- 多说评论框 start -->
<section id="comments">
  <div class="ds-thread"  data-thread-key="/2016/05/13/Python学习笔记/" data-title="Python学习笔记" data-url="http://yoursite.com/2016/05/13/Python学习笔记/" id="ds_thread">
    <noscript>Please enable JavaScript to view the <a href="//duoshuo.com/?ref_noscript">comments powered by duoshuo.</a></noscript>
  </div>
</section>
<!-- 多说评论框 end -->

</section>
        
          
  <div id="toc" class="toc-aside">
  <h2 class="toc-title">Contents</h2>
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Python基础"><span class="toc-number">1.</span> <span class="toc-text">Python基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据类型和变量"><span class="toc-number">1.1.</span> <span class="toc-text">数据类型和变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件判断"><span class="toc-number">1.2.</span> <span class="toc-text">条件判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#循环"><span class="toc-number">1.3.</span> <span class="toc-text">循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#列表"><span class="toc-number">1.4.</span> <span class="toc-text">列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元祖tuple"><span class="toc-number">1.5.</span> <span class="toc-text">元祖tuple</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字典"><span class="toc-number">1.6.</span> <span class="toc-text">字典</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合"><span class="toc-number">1.7.</span> <span class="toc-text">集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数"><span class="toc-number">2.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数参数"><span class="toc-number">2.1.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归函数"><span class="toc-number">2.2.</span> <span class="toc-text">递归函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数式编程"><span class="toc-number">2.3.</span> <span class="toc-text">函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#高阶函数"><span class="toc-number">2.3.1.</span> <span class="toc-text">高阶函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#返回函数"><span class="toc-number">2.3.2.</span> <span class="toc-text">返回函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#匿名函数：不需要显示地定义函数"><span class="toc-number">2.3.3.</span> <span class="toc-text">匿名函数：不需要显示地定义函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#装饰器"><span class="toc-number">2.3.4.</span> <span class="toc-text">装饰器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#偏函数"><span class="toc-number">2.3.5.</span> <span class="toc-text">偏函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象"><span class="toc-number">3.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#继承与多态"><span class="toc-number">3.1.</span> <span class="toc-text">继承与多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象信息"><span class="toc-number">3.2.</span> <span class="toc-text">对象信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例属性和类属性"><span class="toc-number">3.3.</span> <span class="toc-text">实例属性和类属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多重继承"><span class="toc-number">3.4.</span> <span class="toc-text">多重继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定制类"><span class="toc-number">3.5.</span> <span class="toc-text">定制类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用枚举类"><span class="toc-number">3.6.</span> <span class="toc-text">使用枚举类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元类"><span class="toc-number">3.7.</span> <span class="toc-text">元类</span></a></li></ol></li></ol>
    
  </div>

<aside id="sidebar">

  
    
<div class="widget-wrap">
  <h3 class="widget-title">ABOUT ME</h3>
  <ul class="widget about-me">
    
    <li><img class="author" title="About me" src="/images/aboutme.png" /></li>
    
    
    <li>Hi,I'm BeaLin.</li>
    
    <li>Zhejiang University,研究生在读</li>
    
    <li>Email:bealin93@gmail.com</li>
    
    <li>微博：<a href="http://weibo.com/2604578131" target="_BLANK">@程序湲_小苾</a></li>
    
    <li>旧博客：<a href="http://www.cnblogs.com/bylin/" target="_BLANK">博客园</a></li>
    
  </ul>
</div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Deep-Learning/">Deep Learning</a><span class="category-list-count">7</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Deep-Learning/Caffe/">Caffe</a><span class="category-list-count">6</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hadoop/">Hadoop</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Machine-Learning/">Machine Learning</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Python/Scrapy/">Scrapy</a><span class="category-list-count">1</span></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AlexNet/" style="font-size: 13px; color: #7dc3de">AlexNet</a> <a href="/tags/BE/" style="font-size: 13px; color: #7dc3de">BE</a> <a href="/tags/Bagging/" style="font-size: 13px; color: #7dc3de">Bagging</a> <a href="/tags/Bayes/" style="font-size: 14.17px; color: #6dc1b9">Bayes</a> <a href="/tags/Boosting/" style="font-size: 13px; color: #7dc3de">Boosting</a> <a href="/tags/Caffe/" style="font-size: 17.67px; color: #3db94a">Caffe</a> <a href="/tags/Deep-Learning/" style="font-size: 18.83px; color: #2db725">Deep Learning</a> <a href="/tags/Faster-RCNN/" style="font-size: 13px; color: #7dc3de">Faster-RCNN</a> <a href="/tags/Fine-tuning/" style="font-size: 13px; color: #7dc3de">Fine-tuning</a> <a href="/tags/GC/" style="font-size: 13px; color: #7dc3de">GC</a> <a href="/tags/HDFS/" style="font-size: 13px; color: #7dc3de">HDFS</a> <a href="/tags/Hadoop/" style="font-size: 16.5px; color: #4dbc6f">Hadoop</a> <a href="/tags/JMM/" style="font-size: 13px; color: #7dc3de">JMM</a> <a href="/tags/JVM/" style="font-size: 13px; color: #7dc3de">JVM</a> <a href="/tags/Java/" style="font-size: 15.33px; color: #5dbe94">Java</a> <a href="/tags/K近邻/" style="font-size: 13px; color: #7dc3de">K近邻</a> <a href="/tags/ML/" style="font-size: 20px; color: #1db400">ML</a> <a href="/tags/MLE/" style="font-size: 13px; color: #7dc3de">MLE</a> <a href="/tags/NaiveBayes/" style="font-size: 13px; color: #7dc3de">NaiveBayes</a> <a href="/tags/Object-Detection/" style="font-size: 13px; color: #7dc3de">Object Detection</a> <a href="/tags/PCA/" style="font-size: 13px; color: #7dc3de">PCA</a> <a href="/tags/Python/" style="font-size: 14.17px; color: #6dc1b9">Python</a> <a href="/tags/RPC/" style="font-size: 13px; color: #7dc3de">RPC</a> <a href="/tags/SVM/" style="font-size: 13px; color: #7dc3de">SVM</a> <a href="/tags/Scrapy/" style="font-size: 13px; color: #7dc3de">Scrapy</a> <a href="/tags/Stacking/" style="font-size: 13px; color: #7dc3de">Stacking</a> <a href="/tags/决策树/" style="font-size: 13px; color: #7dc3de">决策树</a> <a href="/tags/分布式技术/" style="font-size: 13px; color: #7dc3de">分布式技术</a> <a href="/tags/分布式文件系统/" style="font-size: 13px; color: #7dc3de">分布式文件系统</a> <a href="/tags/半监督学习/" style="font-size: 13px; color: #7dc3de">半监督学习</a> <a href="/tags/多线程/" style="font-size: 13px; color: #7dc3de">多线程</a> <a href="/tags/大数据/" style="font-size: 13px; color: #7dc3de">大数据</a> <a href="/tags/感知机/" style="font-size: 14.17px; color: #6dc1b9">感知机</a> <a href="/tags/机器学习/" style="font-size: 20px; color: #1db400">机器学习</a> <a href="/tags/核方法/" style="font-size: 13px; color: #7dc3de">核方法</a> <a href="/tags/概率图模型/" style="font-size: 13px; color: #7dc3de">概率图模型</a> <a href="/tags/深度学习/" style="font-size: 14.17px; color: #6dc1b9">深度学习</a> <a href="/tags/爬虫/" style="font-size: 13px; color: #7dc3de">爬虫</a> <a href="/tags/特征选择/" style="font-size: 13px; color: #7dc3de">特征选择</a> <a href="/tags/神经网络/" style="font-size: 13px; color: #7dc3de">神经网络</a> <a href="/tags/聚类/" style="font-size: 13px; color: #7dc3de">聚类</a> <a href="/tags/降维/" style="font-size: 13px; color: #7dc3de">降维</a> <a href="/tags/集成方法/" style="font-size: 13px; color: #7dc3de">集成方法</a>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">5</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/01/Hadoop源码分析之RPC/">Hadoop源码分析之RPC一</a>
          </li>
        
          <li>
            <a href="/2017/02/27/机器学习系列—8-神经网络/">机器学习系列—8.神经网络</a>
          </li>
        
          <li>
            <a href="/2017/02/27/机器学习系列—15-概率图模型/">机器学习系列—15.概率图模型</a>
          </li>
        
          <li>
            <a href="/2017/02/27/机器学习系列—14-半监督学习/">机器学习系列—14.半监督学习</a>
          </li>
        
          <li>
            <a href="/2017/02/27/机器学习系列—13-特征选择/">机器学习系列—13.特征选择</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
<div class="widget-wrap">
  <h3 class="widget-title">Recent Comments</h3>
  <ul class="widget ds-recent-comments" data-num-items="5" data-show-avatars="0" data-show-title="1" data-show-time="1"></ul>
</div>
<!-- 需要多说的公用代码 -->


  
    
<div class="widget-wrap">
  <h3 class="widget-title">Links</h3>
  <ul class="widget">
    
    <li><a href="http://yibo.iyiyun.com/js/yibo404/key/1" target="_BLANK">404 page</a></li>
    
  </ul>
</div>


  

</aside>

        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Bea Lin<br>
      
    
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
  var duoshuoQuery = {short_name:"bealin"};
  (function() {
	var ds = document.createElement('script');
	ds.type = 'text/javascript';ds.async = true;
	ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
	ds.charset = 'UTF-8';
	(document.getElementsByTagName('head')[0]
		|| document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
<!-- 多说公共JS代码 end -->



<!-- 百度分享 start -->
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","douban","bdysc","sqq","qq","hi","baidu","huaban","youdao","sdo","mail","xg","diandian","fx","copy","print"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
<!-- 百度分享 end -->


<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<div class="bottom-btn">

	<a class="icon-gotop" href="javascript:void(0)" title="返回顶部"></a>
	<script src="/js/gotop.js"></script>
	<!--
	<script src="/js/gotop.js"></script>
	-->


	<a class="icon-toc-toggle" href="javascript:void(0)" title="文章目录"></a>
	<!--
	<script src="/js/toc_aside_toggle.js"></script>
	-->

</div>
<script src="/js/toc_aside_toggle.js"></script>


<script src="/js/script.js"></script>







  </div>
</body>
</html>
