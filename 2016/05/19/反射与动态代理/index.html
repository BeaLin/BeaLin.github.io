<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>反射与动态代理 | BeaLin&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Programmer,Technology,Software Engineering">
<meta property="og:type" content="article">
<meta property="og:title" content="反射与动态代理">
<meta property="og:url" content="http://yoursite.com/2016/05/19/反射与动态代理/index.html">
<meta property="og:site_name" content="BeaLin's Blog">
<meta property="og:description" content="Programmer,Technology,Software Engineering">
<meta property="og:image" content="http://o73nd1ra4.bkt.clouddn.com/ShowMethod.png">
<meta property="og:image" content="http://o73nd1ra4.bkt.clouddn.com/daili.png">
<meta property="og:image" content="http://o73nd1ra4.bkt.clouddn.com/dtdaili.png">
<meta property="og:updated_time" content="2016-05-19T09:16:41.979Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="反射与动态代理">
<meta name="twitter:description" content="Programmer,Technology,Software Engineering">
<meta name="twitter:image" content="http://o73nd1ra4.bkt.clouddn.com/ShowMethod.png">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?1d80e95307276f5c52c3e32dae69f024";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">BeaLin&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Study, Think, Record</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-github-link" class="nav-icon" href="https://github.com/BeaLin" title="Github" target="_blank"></a>
        
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-反射与动态代理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
<a href="/2016/05/19/反射与动态代理/" class="article-date">
  <time datetime="2016-05-19T08:36:15.000Z" itemprop="datePublished">2016-05-19</time>
</a>


    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      反射与动态代理
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
		
		<div id="toc" class="toc-article">
			<h2 class="toc-title"><span>Contents</span></h2>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Class类"><span class="toc-number">1.</span> <span class="toc-text">Class类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Class对象："><span class="toc-number">1.1.</span> <span class="toc-text">Class对象：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运行时使用类型信息的三种方法（Class-Type）"><span class="toc-number">1.2.</span> <span class="toc-text">运行时使用类型信息的三种方法（Class Type）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java反射API的作用："><span class="toc-number">1.3.</span> <span class="toc-text">java反射API的作用：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态代理"><span class="toc-number">2.</span> <span class="toc-text">动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代理"><span class="toc-number">2.1.</span> <span class="toc-text">代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态代理-1"><span class="toc-number">2.2.</span> <span class="toc-text">动态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态代理的使用场景"><span class="toc-number">2.3.</span> <span class="toc-text">动态代理的使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考链接"><span class="toc-number">3.</span> <span class="toc-text">参考链接</span></a></li></ol>
		
		</div>
		
        <p>原文链接：<a href="http://bealin.github.io/2016/05/13/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" target="_blank" rel="external">反射与动态代理</a><br>写于前面：从某个视频上看到的一句话，存在一定的争议性，有待理解：万事万物皆对象，类也是对象，是Class类型的实例对象，这个对象我们称为该类的类类型<br>本文是在看了《Think in JAVA》、《JAVA核心技术卷》以及相关的一些博客后的总结笔记，纯属个人理解。若有错误，望指出。文末会贴出参考资料的链接。<br><strong>1. java使用类的准备工作</strong><br>(1) <strong>加载</strong>:有类加载器执行，查找字节码，并从字节码中创建一个Class对象<br>(2) <strong>链接</strong>:验证类中的字节码，为静态域分配存储空间。如有必需，也会解析这个类创建的对其他类的所有引用<br>(3) <strong>初始化</strong>:如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块<br>初始化的过程和顺序见Java初始化与清理一文。<br><strong>2. java如何识别对象和类的信息</strong><br>(1) <strong>传统的RTTI</strong>（ Run-Time Type Identification）：在运行时识别对象类型，容器中Objec自动转换为具体类。所有类型转换都是在运行时进行正确性检测。<br>四个关键词:运行时识别、类型转换、类型检查（确保转换的争取性）、类型在编译时必须已知；<br>(2) <strong>反射机制</strong>：运行时获取类信息：用来检查可用的方法，并返回方法名。<br><a id="more"></a></p>
<hr>
<h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><h3 id="Class对象："><a href="#Class对象：" class="headerlink" title="Class对象："></a>Class对象：</h3><p>Class对象：类型信息在运行时的表现；java用Class对象来执行其RTTI。  </p>
<ol>
<li>所有的类都是在对其第一次使用时，动态加载到JVM中的。  </li>
<li>初始化被延迟到了对静态方法（构造器隐式地是静态的）或者非常数静态域进行首次引用时才执行。  </li>
</ol>
<h3 id="运行时使用类型信息的三种方法（Class-Type）"><a href="#运行时使用类型信息的三种方法（Class-Type）" class="headerlink" title="运行时使用类型信息的三种方法（Class Type）"></a>运行时使用类型信息的三种方法（Class Type）</h3><p>Student student=new Student（）；  </p>
<ol>
<li>类名.class（类字面常量；任何一个类都有一个隐含的静态成员变量class）  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c1=Student.class;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong><em>需要注意的是:当使用”.class“来创建对Class对象的引用时，不会自动化地初始化Class对象。</em></strong>  </p>
<ol>
<li><p>调用该类实例对象的getClass方法  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c2=student.getClass()</span><br></pre></td></tr></table></figure>
</li>
<li><p>Class.forName()  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">	try&#123;</span><br><span class="line">		Class c3=Class.forName("com.lby.Student")</span><br><span class="line">	&#125;catch&#123;</span><br><span class="line">	....</span><br><span class="line">	&#125;</span><br><span class="line">```          </span><br><span class="line">* 传递参数需要全限定名（包含包名）  </span><br><span class="line">* 不仅表示了类的类类型，还表示动态加载类  </span><br><span class="line">* 编译时加载和运行加载  </span><br><span class="line">  new的对象是编译时加载（静态加载类）    </span><br><span class="line">* 功能性的类尽量使用动态加载而不是静态加载  </span><br><span class="line"></span><br><span class="line">### 可以通过类的类类型(c1或c2或c3)创建该类的实例对象()（虚拟构造器）  </span><br><span class="line">```java</span><br><span class="line">//其默认无参构造函数</span><br><span class="line">Student student1=（Student）c1.newInstance()</span><br><span class="line">```  </span><br><span class="line">问题:有哪几种方法可以创建一个实例对象，这是其中一种方法。    </span><br><span class="line">个人答案：Java中创建（实例化）对象的五种方式  </span><br><span class="line">(1) 用new语句创建对象，这是最常见的创建对象的方法。  </span><br><span class="line">(2) 通过工厂方法返回对象，如：String str = String.valueOf(23);   </span><br><span class="line">(3) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。如：Object obj = Class.forName("java.lang.Object").newInstance();   </span><br><span class="line">(4) 调用对象的clone()方法。  </span><br><span class="line">(5) 通过I/O流（包括反序列化），如运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。  </span><br><span class="line">### instanceof</span><br><span class="line">RTTI在java中还有一种形式，就是关键字instanceof。它返回一个布尔值，告诉我们对象是否是某个特定类型的实例。  </span><br><span class="line">```java</span><br><span class="line">if(x instanceof Student)  </span><br><span class="line">	printf("is Student Class");</span><br><span class="line">```  </span><br><span class="line">动态的instanceof——Class.isInstance():动态测试对象  </span><br><span class="line">以instanceof的形式与直接比较Class对象有一个很重要的差别：  </span><br><span class="line">* instanceof保持类型的概念，考虑继承  </span><br><span class="line">* 用==比较实际的Class对象没有考虑继承，它或者是这个确切的类型或者不是  </span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">## 反射</span><br><span class="line">### 使用反射的动机——即希望是运行时获取类的信息</span><br><span class="line">1. 基于构件的编程：java通过JavaBeans提供了基于构件的编程  </span><br><span class="line">2. 希望提供在跨网络的远程平台上创建和运行对象的能力，被称为远程方法调用（RMI）——对象序列化  </span><br><span class="line"></span><br><span class="line">### 什么是反射机制?</span><br><span class="line">反射机制使得能够创建一个在编译时完全未知的对象，并调用此对象的方法  </span><br><span class="line">### 反射机制的原理</span><br><span class="line">1. VM检查这个对象，看它属于哪个类（想RTTI那样）  </span><br><span class="line">2. 使用该对象之前必须先加载那个类的Class对象。因此那个类的.class文件对于JVM来说必须是可获取的，要么在本地机器上，要么可通过网络获取  </span><br><span class="line"></span><br><span class="line">### RTTI与反射之间的区别  </span><br><span class="line">**RTTI:**编译器在编译时打开和检查.class文件  </span><br><span class="line">**反射:**.class文件在编译时是不可获取的，而是在运行时打开和检查.class对象  </span><br><span class="line"></span><br><span class="line">### Class类与java.lang.reflact类库一起对反射概念进行支持</span><br><span class="line">java.lang.reflact类库：包含Field、Method以及Constructor类(每个类都实现了Member接口)。这些类型的对象都是由JVM在运行时创建，用以表示未知类里对应的成员。  </span><br><span class="line">1. get()和set()方法读取和修改与Field对象关联的字段  </span><br><span class="line">2. 用invoke()方法调用与Method对象关联的方法。  </span><br><span class="line">3. getFields()、getMethods()和getConstructors()方法返回表示字段、方法以及构造器的对象的数组  </span><br><span class="line"></span><br><span class="line">### 使用relact类库获取所有接口</span><br><span class="line">```java</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line">//Using reflaction to show all the methods of class</span><br><span class="line">public class ShowMethods &#123;</span><br><span class="line">	private static String usage= "usage:\n"+</span><br><span class="line">                   "ShowMethods qualified.class.name\n"+</span><br><span class="line">                   "To show all methods in class or :\n"+</span><br><span class="line">                   "ShowMethods qualified.class.name word\n" +</span><br><span class="line">                   "To search for methods involving 'word'" ;</span><br><span class="line">	private static Pattern p=Pattern. compile("\\w+\\.");</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		if( args. length&lt;1)&#123;</span><br><span class="line">			System. out.println( usage);</span><br><span class="line">            System. exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        int lines=0;</span><br><span class="line">        try&#123;</span><br><span class="line">            Class&lt;?&gt; c=Class. forName(args[0]);</span><br><span class="line">            Method[] methods= c.getMethods();</span><br><span class="line">            Constructor[] ctors=c.getConstructors();</span><br><span class="line">            if( args. length==1)&#123;</span><br><span class="line">            	for(Method method: methods)&#123;</span><br><span class="line">                	System. out.println( p.matcher( method.toString()).replaceAll(""));</span><br><span class="line">                &#125;</span><br><span class="line">                for( Constructor ctor:ctors)&#123;</span><br><span class="line">                    System. out.println( p.matcher( ctor.toString()).replaceAll( ""));</span><br><span class="line">                &#125;</span><br><span class="line">                lines= methods. length+ ctors. length;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for(Method method: methods)&#123;</span><br><span class="line">                    if( method.toString().indexOf( args[1])!=-1)&#123;</span><br><span class="line">                    	System. out.println( p.matcher( method.toString()).replaceAll( ""));</span><br><span class="line">                        lines++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                for( Constructor ctor:ctors)&#123;</span><br><span class="line">                    if( ctor.toString().indexOf( args[1])!=-1)&#123;</span><br><span class="line">                         System. out.println( p.matcher( ctor.toString()).replaceAll( ""));</span><br><span class="line">                         lines++;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">             </span><br><span class="line">		&#125; catch(ClassNotFoundException e)&#123;</span><br><span class="line">        	System. out.println( "No such class:"+ e);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>该程序运行结果如下所示：<br><img src="http://o73nd1ra4.bkt.clouddn.com/ShowMethod.png" alt=""></p>
<h3 id="java反射API的作用："><a href="#java反射API的作用：" class="headerlink" title="java反射API的作用："></a>java反射API的作用：</h3><ol>
<li>获取程序在运行时刻的内部结构。这对于程序的检查工具和调试器来说，是非常实用的功能  </li>
<li>在运行时刻对一个Java对象进行操作。 这些操作包括动态创建一个Java类的对象，获取某个域的值以及调用某个方法。  </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> count; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123; </span><br><span class="line">		count = start; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">(<span class="keyword">int</span> step)</span> </span>&#123; </span><br><span class="line">		count = count + step; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用一般做法和反射API都非常简单。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">MyClass myClass = new MyClass(0); //一般做法</span><br><span class="line">myClass.increase(2);</span><br><span class="line">System.out.println("Normal -&gt; " + myClass.count);</span><br><span class="line">try &#123;</span><br><span class="line">    Constructor constructor = MyClass.class.getConstructor(int.class); //获取构造方法</span><br><span class="line">    MyClass myClassReflect = constructor.newInstance(10); //创建对象</span><br><span class="line">    Method method = MyClass.class.getMethod("increase", int.class);  //获取方法</span><br><span class="line">    method.invoke(myClassReflect, 5); //调用方法</span><br><span class="line">    Field field = MyClass.class.getField("count"); //获取域</span><br><span class="line">    System.out.println("Reflect -&gt; " + field.getInt(myClassReflect)); //获取域的值</span><br><span class="line">&#125; catch (Exception e) &#123; </span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line">```  </span><br><span class="line">使用Java反射API的时候可以绕过Java默认的访问控制检查，比如可以直接获取到对象的私有域的值或是调用私有方法。只需要在获取到Constructor、Field和Method类的对象之后，调用setAccessible方法并设为true即可。  </span><br><span class="line">### 处理泛型</span><br><span class="line">Java 5中引入了泛型的概念之后，Java反射API也做了相应的修改，以提供对泛型的支持。由于类型擦除机制的存在，泛型类中的类型参数等信息，在运行时刻是不存在的。JVM看到的都是原始类型。对此，Java 5对Java类文件的格式做了修订，添加了Signature属性，用来包含不在JVM类型系统中的类型信息。 在运行时刻，JVM会读取Signature属性的内容并提供给反射API来使用。</span><br><span class="line">比如在代码中声明了一个域是List&lt;String&gt;类型的，虽然在运行时刻其类型会变成原始类型List，但是仍然可以通过反射来获取到所用的实际的类型参数。  </span><br><span class="line">```java</span><br><span class="line">Field field = Pair.class.getDeclaredField("myList"); //myList的类型是List </span><br><span class="line">Type type = field.getGenericType(); </span><br><span class="line">if (type instanceof ParameterizedType) &#123;     </span><br><span class="line">    ParameterizedType paramType = (ParameterizedType) type;     </span><br><span class="line">    Type[] actualTypes = paramType.getActualTypeArguments();     </span><br><span class="line">    for (Type aType : actualTypes) &#123;         </span><br><span class="line">        if (aType instanceof Class) &#123;         </span><br><span class="line">            Class clz = (Class) aType;             </span><br><span class="line">            System.out.println(clz.getName()); //输出java.lang.String         </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p><strong>代理</strong>是一种基本的设计模式之一。 代理对象和被代理对象一般实现相同的接口，调用者与代理对象进行交互。代理对象封装一些内部的处理逻辑，如访问控制、远程通信、日志、缓存等。 代理的存在对于调用者来说是透明的，调用者看到的只是接口。比如一个对象访问代理就可以在普通的访问机制之上添加缓存的支持。这种模式在RMI和EJB中都得到了广泛的使用。传统的代理模式的实现，需要在源代码中添加一些附加的类。这些类一般是手写或是通过工具来自动生成。<br>实现一个简单的代理例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">somethingElse</span><span class="params">(String arg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealObject</span> <span class="keyword">implements</span> <span class="title">Interface</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123; System. out.println( <span class="string">"doSomething"</span>);&#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">somethingElse</span><span class="params">(String arg)</span></span>&#123;</span><br><span class="line">            System. out.println( <span class="string">"someThingElse"</span>+ arg);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleProxy</span> <span class="keyword">implements</span> <span class="title">Interface</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> Interface proxied;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">SimpleProxy</span><span class="params">(Interface proxied)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">this</span>. proxied= proxied;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System. out.println( <span class="string">"SimpleProxy doSomething"</span>);</span><br><span class="line">             proxied.doSomething();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">somethingElse</span><span class="params">(String arg)</span> </span>&#123;</span><br><span class="line">            System. out.println( <span class="string">"SimpleProxy somethingElse"</span>+arg);</span><br><span class="line">             proxied.somethingElse( arg);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleProxyDemo</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">(Interface iface)</span></span>&#123;</span><br><span class="line">             iface.doSomething();</span><br><span class="line">             iface.somethingElse( <span class="string">"bonobo"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">             consumer(<span class="keyword">new</span> RealObject ());</span><br><span class="line">             consumer(<span class="keyword">new</span> SimpleProxy( <span class="keyword">new</span> RealObject()));</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://o73nd1ra4.bkt.clouddn.com/daili.png" alt=""><br>SimpleProxy已经被插入到了客户端和RealObject之间，你可以在代理的内部添加一些额外操作。  </p>
<h3 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h3><p><strong>动态代理：</strong>JDK 5引入的动态代理机制，允许开发人员在运行时刻动态的创建出代理并动态地处理对所代理方法的调用。在动态代理上所做的所有调用都会被重定向到单一的调用处理器上，它的工作是揭示调用的类型并确定相应的对策。<br>用动态代理重写SimpleProxyDemo.java<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">class DynamicProxyHandler implements InvocationHandler&#123;</span><br><span class="line">      private Object proxied;</span><br><span class="line">      public DynamicProxyHandler(Object proxied) &#123;</span><br><span class="line">             this. proxied= proxied;</span><br><span class="line">      &#125;</span><br><span class="line">      @Override</span><br><span class="line">      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">            System. out.println( "***proxy:"+ proxy.getClass()+ ".method:"+ method+ ".args:"+ args);</span><br><span class="line">             if( args!= null)</span><br><span class="line">                   for(Object arg: args)</span><br><span class="line">                        System. out.println( " "+ arg);</span><br><span class="line">             return method.invoke( proxied, args);</span><br><span class="line">      &#125;     </span><br><span class="line">&#125;</span><br><span class="line">public class SimpleDynamicProxy &#123;</span><br><span class="line">      public static void consumer(Interface iface)&#123;</span><br><span class="line">             iface.doSomething();</span><br><span class="line">             iface.somethingElse( "bonobo");</span><br><span class="line">      &#125;</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">            RealObject real= new RealObject();</span><br><span class="line">             consumer(real);</span><br><span class="line">            Interface proxy=(Interface)Proxy. newProxyInstance(</span><br><span class="line">                        Interface. class.getClassLoader(),</span><br><span class="line">                         new Class[]&#123;Interface. class&#125;,</span><br><span class="line">                         new DynamicProxyHandler( real));</span><br><span class="line">             consumer(proxy);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://o73nd1ra4.bkt.clouddn.com/dtdaili.png" alt=""><br>通过调用静态方法Proxy.newProxyInstance()可以创建动态代理，这个方法需要得到一个类加载器，一个你希望该代理实现的接口列表（不是类或抽象类），以及InvocationHandler接口的一个实现。在运行时刻，可以动态创建出一个实现了多个接口的代理类。每个代理类的对象都会关联一个表示内部处理逻辑的InvocationHandler接 口的实现。当使用者调用了代理对象所代理的接口中的方法的时候，这个调用的信息会被传递给InvocationHandler的invoke方法。在 invoke方法的参数中可以获取到代理对象、方法对应的Method对象和调用的实际参数。invoke方法的返回值被返回给使用者。这种做法实际上相 当于对方法调用进行了拦截。    </p>
<h3 id="动态代理的使用场景"><a href="#动态代理的使用场景" class="headerlink" title="动态代理的使用场景"></a>动态代理的使用场景</h3><p>需要使用AOP中的方法拦截功能的地方都可以用到动态代理，Spring框架的AOP实现默认也使用动态代理。不过JDK中的动态代理只支持对接口的代理，不能对一个普通的java类提供代理。   </p>
<hr>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.amazon.cn/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E5%9F%83%E5%8F%B2%E5%B0%94/dp/B0011F7WU4?ie=UTF8&amp;camp=536&amp;creative=3132&amp;creativeASIN=B0011F7WU4&amp;linkCode=as2&amp;ref_=as_li_ss_tl&amp;tag=jtianlinsblog-23" target="_blank" rel="external">《Think in Java》</a><br><a href="https://www.amazon.cn/gp/product/B00W34E0LQ/ref=s9_simh_bw_p14_d0_i2?pf_rd_m=A1AJ19PSB66TGU&amp;pf_rd_s=merchandised-search-4&amp;pf_rd_r=CQ16VGJKK5XV21BH4ZNT&amp;pf_rd_t=101&amp;pf_rd_p=284204612&amp;pf_rd_i=658390051" target="_blank" rel="external">JAVA核心技术卷</a> </p>

      
    </div>
    <footer class="article-footer">
	  
	  <!-- 百度分享 Start -->
	  <div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博"></a><a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a></div>
	  <!-- 百度分享 End -->
	  
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/动态代理/">动态代理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/反射/">反射</a></li></ul>

	  
<span>
Updated:<time datetime="2016-05-19T09:16:41.979Z" itemprop="dateModified">2016-05-19</time>
</span>


    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/05/18/java内存管理及垃圾回收机制/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">Java内存管理及垃圾回收机制</div>
    </a>
  
</nav>

  
</article>




<!-- 多说评论框 start -->
<section id="comments">
  <div class="ds-thread"  data-thread-key="/2016/05/19/反射与动态代理/" data-title="反射与动态代理" data-url="http://yoursite.com/2016/05/19/反射与动态代理/" id="ds_thread">
    <noscript>Please enable JavaScript to view the <a href="//duoshuo.com/?ref_noscript">comments powered by duoshuo.</a></noscript>
  </div>
</section>
<!-- 多说评论框 end -->

</section>
        
          
  <div id="toc" class="toc-aside">
  <h2 class="toc-title">Contents</h2>
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Class类"><span class="toc-number">1.</span> <span class="toc-text">Class类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Class对象："><span class="toc-number">1.1.</span> <span class="toc-text">Class对象：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运行时使用类型信息的三种方法（Class-Type）"><span class="toc-number">1.2.</span> <span class="toc-text">运行时使用类型信息的三种方法（Class Type）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java反射API的作用："><span class="toc-number">1.3.</span> <span class="toc-text">java反射API的作用：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态代理"><span class="toc-number">2.</span> <span class="toc-text">动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代理"><span class="toc-number">2.1.</span> <span class="toc-text">代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态代理-1"><span class="toc-number">2.2.</span> <span class="toc-text">动态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态代理的使用场景"><span class="toc-number">2.3.</span> <span class="toc-text">动态代理的使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考链接"><span class="toc-number">3.</span> <span class="toc-text">参考链接</span></a></li></ol>
    
  </div>

<aside id="sidebar">

  
    
<div class="widget-wrap">
  <h3 class="widget-title">ABOUT ME</h3>
  <ul class="widget about-me">
    
    <li><img class="author" title="About me" src="/images/aboutme.png" /></li>
    
    
    <li>Hi,I'm BeaLin.</li>
    
    <li>Zhejiang University,研究生在读</li>
    
    <li>Email:bealin93@gmail.com</li>
    
    <li>微博：<a href="http://weibo.com/2604578131" target="_BLANK">@程序湲_小苾</a></li>
    
    <li>旧博客：<a href="http://www.cnblogs.com/bylin/" target="_BLANK">博客园</a></li>
    
  </ul>
</div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/GC/" style="font-size: 13px; color: #7dc3de">GC</a> <a href="/tags/JMM/" style="font-size: 13px; color: #7dc3de">JMM</a> <a href="/tags/JVM/" style="font-size: 13px; color: #7dc3de">JVM</a> <a href="/tags/Java/" style="font-size: 20px; color: #1db400">Java</a> <a href="/tags/Python/" style="font-size: 16.5px; color: #4dbc6f">Python</a> <a href="/tags/Scrapy/" style="font-size: 13px; color: #7dc3de">Scrapy</a> <a href="/tags/动态代理/" style="font-size: 13px; color: #7dc3de">动态代理</a> <a href="/tags/反射/" style="font-size: 13px; color: #7dc3de">反射</a> <a href="/tags/多线程/" style="font-size: 13px; color: #7dc3de">多线程</a>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">6</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/05/19/反射与动态代理/">反射与动态代理</a>
          </li>
        
          <li>
            <a href="/2016/05/18/java内存管理及垃圾回收机制/">Java内存管理及垃圾回收机制</a>
          </li>
        
          <li>
            <a href="/2016/05/13/java多线程/">java多线程</a>
          </li>
        
          <li>
            <a href="/2016/05/13/使用Scrapy框架爬取数据/">使用Scrapy框架爬取数据</a>
          </li>
        
          <li>
            <a href="/2016/05/13/Python学习笔记/">Python学习笔记</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
<div class="widget-wrap">
  <h3 class="widget-title">Recent Comments</h3>
  <ul class="widget ds-recent-comments" data-num-items="5" data-show-avatars="0" data-show-title="1" data-show-time="1"></ul>
</div>
<!-- 需要多说的公用代码 -->


  
    
<div class="widget-wrap">
  <h3 class="widget-title">Links</h3>
  <ul class="widget">
    
    <li><a href="http://yibo.iyiyun.com/js/yibo404/key/1" target="_BLANK">404 page</a></li>
    
  </ul>
</div>


  

</aside>

        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Bea Lin<br>
      
    
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
  var duoshuoQuery = {short_name:"bealin"};
  (function() {
	var ds = document.createElement('script');
	ds.type = 'text/javascript';ds.async = true;
	ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
	ds.charset = 'UTF-8';
	(document.getElementsByTagName('head')[0]
		|| document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
<!-- 多说公共JS代码 end -->



<!-- 百度分享 start -->
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","douban","bdysc","sqq","qq","hi","baidu","huaban","youdao","sdo","mail","xg","diandian","fx","copy","print"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
<!-- 百度分享 end -->


<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<div class="bottom-btn">

	<a class="icon-gotop" href="javascript:void(0)" title="返回顶部"></a>
	<script src="/js/gotop.js"></script>
	<!--
	<script src="/js/gotop.js"></script>
	-->


	<a class="icon-toc-toggle" href="javascript:void(0)" title="文章目录"></a>
	<!--
	<script src="/js/toc_aside_toggle.js"></script>
	-->

</div>
<script src="/js/toc_aside_toggle.js"></script>


<script src="/js/script.js"></script>







  </div>
</body>
</html>
